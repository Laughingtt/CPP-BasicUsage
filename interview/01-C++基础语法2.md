# CPP

### 1.C/C++内存有哪几种类型

```text
C中，内存分为5个区：堆(malloc)、栈(如局部变量、函数参数)、程序代码区（存放二进制代码）、全局/静态存储区（全局变量、static变量）和常量存储区（常量）。此外，C++中有自由存储区（new）一说。

全局变量、static变量会初始化为缺省值，而堆和栈上的变量是随机的，不确定的
```

### 2.C++堆和栈的区别？

```text
1)堆存放动态分配的对象——即那些在程序运行时动态分配的对象，比如 new 出来的对象，其生存期由程序控制；

2)栈用来保存定义在函数内的非static对象，如局部变量，仅在其定义的程序块运行时才存在；

3)静态内存用来保存static对象，类static数据成员以及定义在任何函数外部的变量，static对象在使用之前分配，程序结束时销毁；

4)栈和静态内存的对象由编译器自动创建和销毁。
```

### 3.C++计算机内部如何存储负数和浮点数？

```text
负数比较容易，就是通过一个标志位和补码来表示。

对于浮点类型的数据采用单精度类型（float）和双精度类型(double)来存储，float数据占用32bit,double数据占用64bit,我们在声明一个变量float f= 2.25f的时候，是如何分配内存的呢？如果胡乱分配，那世界岂不是乱套了么，其实不论是float还是double在存储方式上都是遵从IEEE的规范的，float遵从的是IEEE R32.24 ,而double 遵从的是R64.53。更多可以参考浮点数表示。

无论是单精度还是双精度在存储中都分为三个部分：

1). 符号位(Sign) : 0代表正，1代表为负

2). 指数位（Exponent）:用于存储科学计数法中的指数数据，并且采用移位存储

3). 尾数部分（Mantissa）：尾数部分
其中float的存储方式如下图所示：

```
单精度

![](images/img.png)

双精度
![](images/img_1.png)

### 4.什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？
```text
用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。

1). 使用的时候要记得指针的长度. 
2). malloc的时候得确定在那里free. 
3). 对指针赋值的时候应该注意被赋值指针需要不需要释放. 
4). 动态分配内存的指针最好不要再次赋值. 
5). 在C++中应该优先考虑使用智能指针.
```

### 5.c/c++的内存分配，详细说一下栈、堆、静态存储区？

```text
1）栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等

其操作方式类似于数据结构中的栈。

2）堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。

3）全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。

4）文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放。

5）程序代码区 —存放函数体的二进制代码。
```

### 6.C/C++引用和指针的区别？

```text
指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。

引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）

有多级指针，但是没有多级引用，只能有一级引用。

指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）

sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。

引用访问一个变量是直接访问，而指针访问一个变量是间接访问。

使用指针前最好做类型检查，防止野指针的出现；

引用底层是通过指针实现的；

作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。
```

### 7.C和C++中的强制类型转换？
```text
C中是直接在变量或者表达式前面加上（小括号括起来的）目标类型来进行转换，一招走天下，操作简单，但是由于太过直接，缺少检查，因此容易发生编译检查不到错误，而人工检查又及其难以发现的情况；而C++中引入了下面四种转换：

1)static_cast

    用于基本类型间的转换
    
    不能用于基本类型指针间的转换
    
    用于有继承关系类对象间的转换和类指针间的转换

2)dynamic_cast

    用于有继承关系的类指针间的转换
    
    用于有交叉关系的类指针间的转换
    
    具有类型检查的功能
    
    需要虚函数的支持

3)reinterpret_cast
    
    用于指针间的类型转换
    
    用于整数和指针间的类型转换

4)const_cast

    用于去掉变量的const属性
    
    转换的目标类型必须是指针或者引用
    
    在C++中，普通类型可以通过类型转换构造函数转换为类类型，那么类可以转换为普通类型吗？答案是肯定的。但是在工程应用中一般不用类型转换函数，因为无法抑制隐式的调用类型转换函数（类型转换构造函数可以通过explicit来抑制其被隐式的调用），而隐式调用经常是bug的来源。实际工程中替代的方式是定义一个普通函数，通过显式的调用来达到类型转换的目的。
```

### 8. C++纯虚函数,虚函数，虚函数的实现,什么是虚指针？
```text
纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。
virtual void f()=0;//是一个接口，子类必须实现这个接口虚指针或虚函数指针是虚函数的实现细节。带有虚函数的每一个对象都有一个虚指针指向该类的虚函数表。虚函数 ：虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态覆盖（Override）
纯虚函数和虚函数的区别是，纯虚函数子类必须实现。 纯虚函数的优点：
    （1）可以实现多态特性
    （2）定义一个标准的接口，在派生类中必须予以重写以实现多态性。
抽象类 ：包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。

多态性可分为两类：
静态多态和动态多态。函数重载和运算符重载实现的多态属于静态多态，动态多态性是通过虚函数实现的。

虚函数与构造函数，析构函数，成员函数的关系

为什么基类析构函数是虚函数？

编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。

为什么构造函数不能为虚函数

虚函数采用一种虚调用的方法。需调用是一种可以在只有部分信息的情况下工作的机制。如果创建一个对象，则需要知道对象的准确类型，因此构造函数不能为虚函数。

如果虚函数是有效的，那为什么不把所有函数设为虚函数？

不行。因为每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。
```

### 9.内联函数与宏有什么区别

```text
内联函数在编译时展开，宏在预编译时展开
在编译的时候内联函数可以直接被嵌入到目标代码中，而宏只是一个简单的文本替换
内联函数可以完成诸如类型检测、语句是否正确等编译功能，宏就不具备这样的功能
inline函数是函数，宏不是函数。

宏定义 #define 和 const 常量
    宏定义 #define	const 常量
    宏定义，相当于字符替换	常量声明
    预处理器处理	编译器处理
    无类型安全检查	有类型安全检查
    不分配内存	要分配内存
    存储在代码段	存储在数据段
    可通过 #undef 取消	不可取消
```

### 10.什么是预编译？何时需要预编译？
```text
预编译又称为预处理 , 是做些代码文本的替换工作。
处理 # 开头的指令 , 比如拷贝 #include 包含的文件代码， #define 宏定义的替换 , 条件编译等。
c 编译系统在对程序进行通常的编译之前，先进行预处理。 
c 提供的预处理功能主要有以下三 种： 
    1 ）宏定义　 
    2 ）文件包含　 
    3 ）条件编译
```

### 11.C++文件编译与执行的四个阶段

```text
第一阶段：预处理阶段。根据文件中的预处理指令来修改源文件的内容。如#include指令，作用是把头文件的内容添加到.cpp文件中。

第二阶段：编译阶段，将其翻译成等价的中间代码或汇编代码。

第三阶段：汇编阶段，把汇编语言翻译成目标机器指令。

第四阶段：是链接，例如，某个源文件中的函数可能引用了另一个源文件中定义的某个函数；在程序中可能调用了某个库文件中的函数。

```

### 12.STL，详细说明STL如何实现vector。


```text
STL是标准模版库，由容器算法迭代器组成。

STL有以下的一些优点：

（1）可以很方便的对一堆数据进行排序（调用sort（））；

（2）调试程序时更加安全和方便；

（3）stl是跨平台的，在linux下也能使用。

vector实质上就是一个动态数组，会根据数据的增加,动态的增加数组空间。

什么是容器。如何实现？

容器是一种类类型，用来存储数据

STL有7种主要容器：vector,list,deque,map,multimap,set,multiset.
```

### 13.什么是智能指针？

```text
当类中有指针成员时，一般有两种方式来管理指针成员：一是采用值型的方式管理，每个类对象都保留一份指针指向的对象的拷贝；另一种更优雅的方式是使用智能指针，从而实现指针指向的对象的共享。

智能指针的一种通用实现技术是使用引用计数。智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。

每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；
对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

shared_ptr
    多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
    
    支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

weak_ptr
    weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
    可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

unique_ptr
    unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。
    unique_ptr 用于取代 auto_ptr

auto_ptr
    被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。

auto_ptr 与 unique_ptr 比较

    auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
    auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；
```

### 14.进程与线程

#### 对于有线程系统：
a.进程是资源分配的独立单位

b.线程是资源调度的独立单位

```text
进程之间的通信方式以及优缺点
管道（PIPE）
    有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
    优点：可以实现任意关系的进程间的通信
    缺点：
    长期存于系统中，使用不当容易出错
    缓冲区有限
无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
    优点：简单方便
    缺点：
    局限于单向通信
    只能创建在它的进程以及其有亲缘关系的进程之间
    缓冲区有限
信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
    优点：可以同步进程
    缺点：信号量有限
信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
    优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
    缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
    优点：无须复制，快捷，信息量大
    缺点：
    通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
    利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
套接字（Socket）：可用于不同计算机间的进程通信
    优点：
    传输数据为字节级，传输数据可自定义，数据量小效率高
    传输数据时间短，性能高
    适合于客户端和服务器端之间信息实时交互
    可以加密,数据安全性强
    缺点：需对传输的数据进行解析，转化成应用级的数据。
```

### 15 C++中 struct 和 class
```text
总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

区别
最本质的一个区别就是默认的访问控制
默认的继承访问权限。struct 是 public 的，class 是 private 的。
struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。
```

### 16.五种I/O 模式，

```text
五种I/O 模式：
【1】       阻塞I/O           (Linux下的I/O操作默认是阻塞I/O，即open和socket创建的I/O都是阻塞I/O)
【2】       非阻塞 I/O        (可以通过fcntl或者open时使用O_NONBLOCK参数，将fd设置为非阻塞的I/O)
【3】       I/O 多路复用     (I/O多路复用，通常需要非阻塞I/O配合使用)
【4】       信号驱动 I/O    (SIGIO)
【5】        异步 I/O
```

### 海量数据处理
```text
bitmap

BloomFilter原理、

它实际上是一个很长的二进制向量和一系列随机映射函数（Hash函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Bloom Filter广泛的应用于各种需要查询的场合中，如Orocle的数据库，Google的BitTable也用了此技术。
Bloom Filter特点：
不存在漏报（False Negative），即某个元素在某个集合中，肯定能报出来。
可能存在误报（False Positive），即某个元素不在某个集合中，可能也被爆出来。
确定某个元素是否在某个集合中的代价和总的元素数目无关。
Trie树原理、 单词搜索树

Map-Reduce原理
BTree原理,B+树原理
```